// This file is @generated by prost-build.
/// this is the root message that captures all possible
/// logical plan messages which can be sent across
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LMessage {
    #[prost(oneof = "l_message::Extension", tags = "1")]
    pub extension: ::core::option::Option<l_message::Extension>,
}
/// Nested message and enum types in `LMessage`.
pub mod l_message {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Extension {
        #[prost(message, tag = "1")]
        Sample(super::LSample),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LSample {
    #[prost(float, tag = "1")]
    pub fraction: f32,
    #[prost(int64, optional, tag = "2")]
    pub seed: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMessage {
    #[prost(oneof = "p_message::Extension", tags = "1, 2")]
    pub extension: ::core::option::Option<p_message::Extension>,
}
/// Nested message and enum types in `PMessage`.
pub mod p_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Extension {
        #[prost(bytes, tag = "1")]
        Opaque(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "2")]
        Sample(super::PSample),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PSample {
    #[prost(float, tag = "1")]
    pub fraction: f32,
    #[prost(int64, optional, tag = "2")]
    pub seed: ::core::option::Option<i64>,
}
